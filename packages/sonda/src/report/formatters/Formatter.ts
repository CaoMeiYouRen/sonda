import { basename, dirname, format } from 'path';
import { mkdir, writeFile } from 'fs/promises';
import { getAllFiles } from '../../utils.js';
import type { Config } from '../../config.js';
import type { JsonReport } from '../types.js';

export abstract class Formatter {
	protected config: Config;

	protected abstract extension: string;

	protected abstract parse( data: JsonReport ): Promise<string> | string;

	public constructor( config: Config ) {
		this.config = config;
	}

	/**
	 * Writes the report to the file system and returns the path to the report.
	 */
	public async write( data: JsonReport ): Promise<string> {
		const path = await this.getReportPath();
		const content = await this.parse( data );
	
		// Ensure the output directory exists
		await mkdir( dirname( path ), { recursive: true } );

		// Write the report to the file system
		await writeFile( path, content );

		// Return the path to the report
		return path;
	}

	/**
	 * Generates a unique report name based on the existing files in
	 * the specified directory. The name is generated by appending
	 * a version number to the base name.
	 */
	protected async getReportPath(): Promise<string> {
		const { filename, outputDir } = this.config;
		const regex = new RegExp( `^${ filename }_(\\d+)\\${ this.extension }$` );

		const versions = ( await getAllFiles( outputDir ) )
			.map( path => basename( path ).match( regex ) )
			.filter( match => match !== null )
			.map( match => parseInt( match[ 1 ], 10 ) );
	
		const maxVersion = Math.max( ...versions, -1 );
		const version = String( maxVersion + 1 );

		return format( {
			dir: this.config.outputDir,
			name: `${ filename }_${ version }`,
			ext: this.extension
		} );
	}
}
