import { version } from 'sonda/package.json' with { type: 'json' };
import open from 'tiny-open';
import { sortByKey } from '../utils.js';
import { HtmlFormatter } from './formatters/HtmlFormatter.js';
import { JsonFormatter } from './formatters/JsonFormatter.js';
import { updateOutputs } from './processors/outputs.js';
import { updateInputs } from './processors/inputs.js';
import { updateDependencies } from './processors/dependencies.js';
import type { Formatter } from './formatters/Formatter.js';
import type { Config, Integration, Format } from '../config.js';

const formatters: Record<Format, new ( config: Config ) => Formatter> = {
	'html': HtmlFormatter,
	'json': JsonFormatter
};

export class ReportProducer {
	public metadata: Metadata;

	constructor(
		public config: Config,
		public resources: Array<Resource> = [],
		public edges: Array<Edge> = [],
		public dependencies: Array<Dependency> = [],
		public issues: Array<Issue> = []
	) {
		this.metadata = {
			version,
			integration: config.integration,
			sources: config.sources,
			gzip: config.gzip,
			brotli: config.brotli
		};
	}

	async generate( assets: Array<string> ): Promise<void> {
		updateOutputs( this, assets );
		// TODO: This may not be needed
		// updateInputs( this );
		updateDependencies( this );

		const config = this.config;
		const formatter = new formatters[ config.format ]( config );
		const path = await formatter.write( this.#getFormattedData() );

		if ( config.open ) {
			await open( path );
		}
	}

	#getFormattedData(): JsonReport {
		return {
			metadata: this.metadata,
			resources: sortByKey( this.resources, 'name' ),
			edges: this.edges,
			dependencies: sortByKey( this.dependencies, 'name' ),
			issues: this.issues
		};
	}
}

export interface JsonReport {
	/**
	 * Metadata about the report, including the version of Sonda used to generate it,
	 * the integration used, and the options passed to Sonda.
	 */
	metadata: Metadata;

	/**
	 * List of all input and output resources.
	 */
	resources: Array<Resource>;

	/**
	 * List of all connections between resources.
	 */
	edges: Array<Edge>;

	/**
	 * List of all detected external dependencies and their paths. If
	 * a dependency has more than one path, it's likely duplicated and
	 * bundled in multiple copies.
	 */
	dependencies: Array<Dependency>;

	/**
	 * List of issues detected in the outputs.
	 */
	issues: Array<Issue>;
}

export interface Metadata {
	/**
	 * Version of Sonda used to generate the report.
	 */
	version: string;

	/**
	 * Integration used to generate the report.
	 */
	integration: Integration;

	/**
	 * The normalized value of the `sources` option passed to Sonda.
	 */
	sources: boolean;

	/**
	 * The normalized value of the `gzip` option passed to Sonda.
	 */
	gzip: boolean;

	/**
	 * The normalized value of the `brotli` option passed to Sonda.
	 */
	brotli: boolean;
}

export type Resource = 
	| SourceResource
	| AssetResource
	| ChunkResource
	| SourceMapResource;

/**
 * Input resource loaded from the filesystem by the bundler.
 *
 * Refer to the `ResourceBase` interface for properties details.
 */
export interface SourceResource extends ResourceBase {
	kind: 'source';
	name: string;
	type: FileType;
	format: ModuleFormat | null;
	uncompressed: number;
	gzip: 0;
	brotli: 0;
	parent: null;
	content: string | null;
	mappings: null;
}

/**
 * Output resource generated by the bundler.
 *
 * Refer to the `ResourceBase` interface for properties details.
 */
export interface AssetResource extends ResourceBase {
	kind: 'asset'
	name: string;
	type: FileType;
	format: null;
	uncompressed: number;
	gzip: number;
	brotli: number;
	parent: null;
	content: string | null;
	mappings: string | null;
}

/**
 * Resources from the source map generated by the bundler. It's part
 * of the input resource after the bundler has processed it, so after
 * tree-shaking, minification, etc.
 *
 * Refer to the `ResourceBase` interface for properties details.
 */
export interface ChunkResource extends ResourceBase {
	kind: 'chunk';
	name: string;
	type: FileType;
	format: ModuleFormat | null;
	uncompressed: number;
	gzip: number;
	brotli: number;
	parent: string;
	content: string | null;
	mappings: null;
}

/**
 * Resource from the source map of the input resource. It represents
 * the original source 
 */
export interface SourceMapResource extends ResourceBase {
	kind: 'sourcemap';
	name: string;
	type: FileType;
	format: ModuleFormat | null;
	uncompressed: number;
	gzip: number;
	brotli: number;
	parent: string;
	content: string | null;
	mappings: null;
}

export interface ResourceBase {
	/**
	 * Information where the resource is from.
	 */
	kind: ResourceKind;

	/**
	 * Path to the resource.
	 *
	 * If the `source` is `sourcemap`, the file may not exist in the filesystem.
	 */
	name: string;

	/**
	 * Type of the resources, determined by the file extension.
	 */
	type: FileType;

	/**
	 * Format of the module, if the resource type is `script`.
	 */
	format: ModuleFormat | null;

	/**
	 * Size of the resource without any compression.
	 */
	uncompressed: number;

	/**
	 * Size of the resource after GZIP compression.
	 * 
	 * This value is only available when the `gzip` option is enabled.
	 */
	gzip: number;

	/**
	 * Size of the resource after Brotli compression.
	 * 
	 * This value is only available when the `brotli` option is enabled.
	 */
	brotli: number;

	/**
	 * Parent of the resource.
	 *
	 * If the `source` is `bundler`, this resource is a part of the output
	 * asset and value of `parent` is the name of the output asset.
	 * 
	 * If the `source` is `sourcemap`, this resource is a part of the source
	 * map of other resource and value of `parent` is the name of that resource.
	 */
	parent: string | null;

	/**
	 * Content of the resource.
	 * 
	 * This value is only available when the `deep` option is enabled.
	 */
	content: string | null;

	/**
	 * If the resource has a source map, this values includes decoded mappings from it.
	 *
	 * This value is only available when the `deep` option is enabled.
	 */
	mappings: string | null;
}

export type Sizes = Pick<ResourceBase, 'uncompressed' | 'gzip' | 'brotli'>;

export interface Edge {
	source: string;
	target: string;
}

export interface Dependency {
	name: string;
	paths: Array<string>;
}

export interface Issue {
	type: string;
	data: unknown;
}

export type ResourceKind =
	/**
	 * Resource used by the bundler to generate the output
	 */
	| 'source'

	/**
	 * Output file generated by the bundler
	 */
	| 'asset'

	/**
	 * Part of the output file generated by the bundler.
	 * This is source after tree-shaking, minification, etc.
	 */
	| 'chunk'

	/**
	 * Resource found in the source map of one of the sources
	 */
	| 'sourcemap'

export type FileType = 
	| 'component'
	| 'font'
	| 'image'
	| 'script'
	| 'style'
	| 'other';

export type ModuleFormat = 
	| 'esm'
	| 'cjs'
	| 'amd'
	| 'umd'
	| 'iife'
	| 'system'
	| 'unknown';
